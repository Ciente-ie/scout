();
                    const pdfHeight = pdf.internal.pageSize.getHeight();
                    const canvasWidth = pageCanvas.width;
                    const canvasHeight = pageCanvas.height;
                    const canvasRatio = canvasHeight / canvasWidth;
                    
                    let imgWidth = pdfWidth;
                    let imgHeight = pdfWidth * canvasRatio;

                    // Se a altura da imagem for maior que a altura do PDF, ajuste as dimensões
                    if (imgHeight > pdfHeight) {
                        imgHeight = pdfHeight;
                        imgWidth = imgHeight / canvasRatio;
                    }
                    
                    const x = (pdfWidth - imgWidth) / 2;
                    const y = (pdfHeight - imgHeight) / 2;

                    pdf.addImage(pageImgData, 'JPEG', x, y, imgWidth, imgHeight);
                }

                const fileName = `Relatorio_${match.myTeamName}_vs_${match.opponentName}_${match.date}.pdf`;
                pdf.save(fileName);

            } catch (error) {
                showErrorMessage('Ocorreu um erro ao gerar o PDF.', error);
            } finally {
                document.body.removeChild(tempContainer);
                text.classList.remove('hidden');
                loader.classList.add('hidden');
                button.disabled = false;
            }
        }

        function renderOnFieldPlayers() {
            const container = document.getElementById('on-field-players');
            if (!container || !appState.activeMatchId) return;

            const match = appState.matches.find(m => m.id === appState.activeMatchId);
            if (!match) return;

            const { onField } = getPlayersOnFieldAndBench(match);
            const sortedOnFieldPlayers = onField
                .map(pid => appState.players.find(p => p.id === pid))
                .filter(Boolean)
                .sort((a, b) => a.name.localeCompare(b.name));

            container.innerHTML = sortedOnFieldPlayers.map(player => 
                `<button class="action-btn bg-gray-700 hover:bg-gray-600 text-white truncate" onclick="selectPlayerForAction('${player.id}')" title="${player.name}">
                    ${player.name}
                </button>`
            ).join('');
        }

        window.showHalftimeReport = function() {
            const match = appState.matches.find(m => m.id === appState.activeMatchId);
            if (!match) return;
            cancelPlayerSelection();

            const contentContainer = document.getElementById('halftime-report-content');
            if (!contentContainer) return;
            
            contentContainer.innerHTML = renderReportContentForPDF(match, 1);
            
            openModal('halftime-report-modal');

            setTimeout(() => {
                destroyCharts(); 
                renderChartsForReport(match, 1);
            }, 100);
        }

        window.exportActionsToTXT = function() {
            const matchId = document.getElementById('report-match-select').value;
            if (!matchId) return alert('Selecione uma partida primeiro.');

            const match = appState.matches.find(m => m.id === matchId);
            if (!match || !match.events) return alert('Nenhum evento encontrado para esta partida.');

            let txtContent = `Relatório de Ações - ${match.myTeamName} vs ${match.opponentName} - ${new Date(match.date).toLocaleDateString('pt-BR', {timeZone: 'UTC'})}\n`;
            txtContent += "====================================================================\n";
            txtContent += "Tempo | Período | Setor    | Ação               | Detalhe      | Jogador\n";
            txtContent += "--------------------------------------------------------------------\n";

            const sortedEvents = [...match.events].sort((a, b) => a.time - b.time);

            sortedEvents.forEach(event => {
                const timeStr = formatTime(event.time).padEnd(6);
                const periodStr = (event.period + 'ºT').padEnd(8);
                const zoneStr = (event.zone || 'N/A').padEnd(9);
                const actionStr = (event.action || '').replace(/_/g, ' ').padEnd(19);
                const detailStr = (event.detail && event.detail !== 'N/A' ? event.detail.replace(/_/g, ' ') : '').padEnd(13);
                const playerStr = event.playerName || 'N/A';
                txtContent += `${timeStr}| ${periodStr}| ${zoneStr}| ${actionStr}| ${detailStr}| ${playerStr}\n`;
            });

            const blob = new Blob([txtContent], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            const fileName = `Acoes_${match.myTeamName}_vs_${match.opponentName}_${match.date}.txt`;
            link.setAttribute('download', fileName);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        window.exportPerformancesToTXT = function() {
            const performances = {};
            appState.players.forEach(p => {
                performances[p.id] = { name: p.name, position: p.position, matchPerformances: [] };
            });

            const finishedMatches = appState.matches.filter(m => m.status === 'finished' && m.ratings);
            if (finishedMatches.length === 0) {
                return alert("Nenhuma partida finalizada com avaliações para exportar.");
            }

            const minutesByMatch = finishedMatches.reduce((acc, match) => {
                acc[match.id] = calculateMinutesPlayed(match);
                return acc;
            }, {});

            finishedMatches.forEach(match => {
                const matchEvents = match.events || [];
                const matchMinutes = minutesByMatch[match.id] || {};
                
                Object.entries(match.ratings).forEach(([playerId, rates]) => {
                    if (performances[playerId] && rates.played) {
                        const playerEvents = matchEvents.filter(e => e.playerId === playerId);
                        const goals = playerEvents.filter(e => e.action === 'gol').length;
                        const assists = matchEvents.filter(e => e.assistId === playerId).length;
                        const shots = playerEvents.filter(e => e.action === 'finalizacao').length;
                        const duelsWon = playerEvents.filter(e => e.action === 'duelo_ganho').length;
                        const duelsLost = playerEvents.filter(e => e.action === 'duelo_perdido').length;
   
                        const avg = (parseFloat(rates.tecnico) + parseFloat(rates.tatico) + parseFloat(rates.fisico) + parseFloat(rates.comportamental)) / 4;
                        performances[playerId].matchPerformances.push({
                            matchDate: new Date(match.date).toLocaleDateString('pt-BR', { timeZone: 'UTC' }),
                            opponentName: match.opponentName,
                            overall: avg,
                            minutesPlayed: matchMinutes[playerId] || 0,
                            goals,
                            assists,
                            shots,
                            duelsWon,
                            duelsLost
                        });
                    }
                });
            });

            const sortedPerformances = Object.values(performances).map(p => {
                const overallScores = p.matchPerformances.map(mp => mp.overall);
                const overallAvg = overallScores.length > 0 ? (overallScores.reduce((a, b) => a + b, 0) / overallScores.length) : 0;
                const totalMinutesPlayed = p.matchPerformances.reduce((acc, mp) => acc + mp.minutesPlayed, 0);
                const totalGoals = p.matchPerformances.reduce((acc, mp) => acc + mp.goals, 0);
                const totalAssists = p.matchPerformances.reduce((acc, mp) => acc + mp.assists, 0);
                const totalShots = p.matchPerformances.reduce((acc, mp) => acc + mp.shots, 0);
                const totalDuelsWon = p.matchPerformances.reduce((acc, mp) => acc + mp.duelsWon, 0);
                const totalDuelsLost = p.matchPerformances.reduce((acc, mp) => acc + mp.duelsLost, 0);
                return { ...p, overallAvg, totalMinutesPlayed, totalGoals, totalAssists, totalShots, totalDuelsWon, totalDuelsLost };
            }).sort((a, b) => b.overallAvg - a.overallAvg);

            let txtContent = "Relatório de Desempenho dos Jogadores\n";
            txtContent += "========================================\n\n";

            sortedPerformances.forEach(p => {
                if (p.matchPerformances.length === 0) return;

                txtContent += `JOGADOR: ${p.name} (${p.position})\n`;
                txtContent += `----------------------------------------\n`;
                txtContent += `Média Geral: ${p.overallAvg.toFixed(1)}\n`;
                txtContent += `Jogos: ${p.matchPerformances.length}\n`;
                txtContent += `Minutos Jogados: ${p.totalMinutesPlayed}\n`;
                txtContent += `Gols: ${p.totalGoals}\n`;
                txtContent += `Assistências: ${p.totalAssists}\n`;
                txtContent += `Finalizações: ${p.totalShots}\n`;
                txtContent += `Duelos Ganhos / Perdidos: ${p.totalDuelsWon} / ${p.totalDuelsLost}\n\n`;
                txtContent += "DETALHES POR PARTIDA:\n";
                txtContent += "Data       | Adversário        | Nota | Min | G | A | Fin | Duelos G/P\n";
                p.matchPerformances.forEach(mp => {
                    const date = mp.matchDate.padEnd(11);
                    const opponent = mp.opponentName.padEnd(18);
                    const overall = mp.overall.toFixed(1).padEnd(5);
                    const mins = String(mp.minutesPlayed).padEnd(4);
                    const goals = String(mp.goals).padEnd(2);
                    const assists = String(mp.assists).padEnd(2);
                    const shots = String(mp.shots).padEnd(4);
                    const duels = `${mp.duelsWon}/${mp.duelsLost}`;
                    txtContent += `${date}| ${opponent}| ${overall}| ${mins}| ${goals}| ${assists}| ${shots}| ${duels}\n`;
                });
                txtContent += "\n========================================\n\n";
            });

            const blob = new Blob([txtContent], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const fileName = `Desempenho_Jogadores_${new Date().toISOString().slice(0,10)}.txt`;
            link.setAttribute('download', fileName);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        firebaseAuth();
    </script>
</body>
</html>
